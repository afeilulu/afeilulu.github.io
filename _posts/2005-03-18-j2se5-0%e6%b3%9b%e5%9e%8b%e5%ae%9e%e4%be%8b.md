---
layout: post
title: J2SE5.0泛型实例
date: 2005-03-18 15:39
author: afeilulu
comments: true
categories: [program]
---
<div id="msgcns!4C815953D6B638F4!146" class="bvMsg"><p> <font size="3">简介</font></p> <p><font size="3"></font><font size="2">泛型其实并不是一种新的语言元素，<font face="Times New Roman">C++</font>中早就就有，但是在<font face="Times New Roman">C++</font>之后的<font face="Times New Roman">java</font>却没有吸收这个特性，现在<font face="Times New Roman">Java</font>也有了泛型的特性，大概也和<font face="Times New Roman">.Net</font>的竞争有关系吧。</font></p> <p><font size="2"></font><font size="2">首先看泛型的一个应用。</font></p> <p><font size="2">在过去，我们可能经常要写一些类似这样的代码：</font></p> <p><font face="Courier New" color="#0000ff" size="2">List stringList=new LinkedList();</font></p> <p><font face="Courier New" color="#0000ff" size="2">stringList.add(&quot;firstString&quot;);</font></p> <p><font face="Courier New" color="#0000ff" size="2">stringList.add(&quot;secondString&quot;);</font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">String str=(String)stringList.iterator().next();</font></font></font></font> <p>  <p><font size="2">实际上第三行对<font face="Times New Roman">String</font>的类型转换意义并不大，因为通常我们如果在操作一个<font face="Times New Roman">List</font>，都是知道这个<font face="Times New Roman">List</font>里面放的是什么类型对象的，但是我们如果不这样写又通不过语法检查。</font> <p><font size="2">利用<font face="Times New Roman">java</font>的泛型机制，我们可以这么写：</font></p> <p><font face="Courier New" color="#0000ff" size="2">List&lt;String&gt; stringList=new LinkedList&lt;String&gt;();</font></p> <p><font face="Courier New" color="#0000ff" size="2">stringList.add(&quot;firstString&quot;);</font></p> <p><font face="Courier New" color="#0000ff" size="2">stringList.add(&quot;secondString&quot;);</font></p> <p><font face="Courier New" color="#0000ff" size="2">String str=stringList.iterator().next();</font></p> <p><font size="2">这样做的好处是在定义容器的时候就指明了容器中的类型，一方面我们不再需要取一个元素时候做强制类型转换，另外一方面如果在这个容器中放入的对象类型不符合要求，那么会在</font><strong>编译</strong><font size="2">时候产生一个错误，而不是在运行时候才抛出一个异常。</font></p> <p><font size="2">另外这样也提高了程序的可读性。</font></p> <font size="3">泛型类型的定义</font> <p><font size="2">下面是一个简单的使用泛型类的定义：</font></p> <p><font face="Courier New" color="#0000ff" size="2">public class MyGenericClass&lt;T&gt; &#123;</font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  private T value;</font></font></font></font></p> <p> <p><font face="Courier New" color="#0000ff" size="2"></font> </p> <p></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  public T getValue() &#123;</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     return value;</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#125;</font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">  </font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  public void setValue(T value) &#123;</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     this.value = value;</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#125;   </font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">值得注意的一点是，静态变量不能够使用泛型定义，也就是说类似下面的语句是</font><strong>非法</strong><font size="2">的： <p></p></font> <p></p> <p><font face="Courier New" color="#0000ff" size="2">public class MyGenericClass&lt;T&gt; &#123;</font></p> <p><font><font size="2"><font color="#0000ff"><font face="Courier New">  public static T value;//</font></font>错误的定义</font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">此外，泛型的定义不会被继承，举个例子来说，如果<font face="Times New Roman">A</font>是<font face="Times New Roman">B</font>的子类，而<font face="Times New Roman">C</font>是一个声明了泛型定义的类型的话，<font face="Times New Roman">C&lt;A&gt;</font>不是<font face="Times New Roman">C&lt;B&gt;</font>的子类。为了更好的说明，可以看下面的代码，这段代码是</font><strong>错误</strong><font size="2">的。</font></p> <p><font face="Courier New" color="#0000ff" size="2">List&lt;String&gt; strList =new ArrayList&lt;String&gt;();</font></p> <p><font><font size="2"><font face="Courier New" color="#0000ff">List&lt;Object&gt; objList=strList;  //</font>错误的赋值 <p></p></font></font> <p></p> <p><font size="2">不过这样一段代码是正确的：</font></p> <p><font face="Courier New" color="#0000ff" size="2">List&lt;Object&gt; strList =new ArrayList&lt;Object&gt;();</font></p> <p><font face="Courier New" color="#0000ff" size="2">strList.add(&quot;jsdkfjsdl&quot;);</font></p> <font size="3">统配类型</font> <p><font size="2">假设我们需要这样一个函数，使用它可以把一个集合中所有的元素打印出来，在以前我们可能这样定义：</font></p> <p><font face="Courier New" color="#0000ff" size="2">void printCollection(Collection c) &#123;</font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  Iterator i = c.iterator();</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  for (k = 0; k &lt; c.size(); k++)</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#123; </font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     System.out.println(i.next());</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#125;</font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">使用新的泛型特性我们可能会这样写：</font></p> <p><font face="Courier New" color="#0000ff" size="2">void printCollection(Collection&lt;Object&gt; c) </font></p> <p><font face="Courier New" color="#0000ff" size="2">&#123; </font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  for (Object e : c) </font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#123; </font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     System.out.println(e);</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#125;</font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">但是这样有一个问题，假如我们现在有个对象类型是<font face="Times New Roman">Collection&lt;String&gt;</font>，那么我们不能够将它作为参数传给<font face="Times New Roman">printCollection</font>，因为<font face="Times New Roman">Collection&lt;String&gt;</font>并不是<font face="Times New Roman">Collection&lt;Object&gt;</font>的子类。</font></p> <p><font size="2">为了解决这个问题，我们可以使用统配类型<font face="Times New Roman">?</font>，也就是定义成下面这个样子：</font></p> <p><font face="Courier New" color="#0000ff" size="2">void printCollection(Collection&lt;?&gt; c) </font></p> <p><font face="Courier New" color="#0000ff" size="2">&#123; </font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  for (Object e : c) </font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#123; </font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     System.out.println(e);</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#125;</font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">可以说<font face="Times New Roman">Collection&lt;?&gt;</font>是所有<font face="Times New Roman">Collection</font>的父类。</font></p> <p><font size="2">再来看一段下面的代码</font></p> <p><font face="Courier New" color="#0000ff" size="2">private void clearAllMaps(Collection&lt;Map&gt; c)</font></p> <p><font face="Courier New" color="#0000ff" size="2">&#123;</font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     for(Map m:c)</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     &#123;</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">         m.clear();</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     &#125;</font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">毫无疑问，它也存在上面我们所说的问题，也就是对<font face="Times New Roman">HashMap</font>之类<font face="Times New Roman">Map</font>的子类无法进行操作，但是如果我们将参数改成<font face="Times New Roman">Collection&lt;?&gt;</font>又不大合理，因为我们只希望对父类为<font face="Times New Roman">Map</font>的子类进行操作，那么我们可以这样改写：</font></p> <p><font face="Courier New" color="#0000ff" size="2">private void clearAllMaps(Collection&lt;? extends Map&gt; c)</font></p> <p><font face="Courier New" color="#0000ff" size="2">&#123;</font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  for(Map m:c)</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#123;</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">     m.clear();</font></font></font></font></p> <p><font color="#0000ff"><font><font face="Courier New"><font size="2">  &#125;</font></font></font></font></p> <p><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">类似于<font face="Times New Roman">? extends Map</font>之类的统配符称为限定统配类型。</font></p> <p><font size="2">假设一个对象<font face="Times New Roman">h</font>类型为<font face="Times New Roman">Collection&lt;HashMap&gt;</font>，那么我们将<font face="Times New Roman">h</font>作为参数传给<font face="Times New Roman">clearAllMaps</font>，如下面一段代码所示：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">List&lt;HashMap&lt;String,String&gt;&gt; h=new ArrayList&lt;HashMap&lt;String,String&gt;&gt;();</font></p> <p><font face="Courier New" color="#0000ff" size="2">HashMap&lt;String,String&gt; m=new HashMap&lt;String,String&gt;();</font></p> <p><font face="Courier New" color="#0000ff" size="2">m.put(&quot;key&quot;,&quot;value&quot;);</font></p> <p><font face="Courier New" color="#0000ff" size="2">h.add(m);</font></p> <p><font face="Courier New" color="#0000ff" size="2">clearAllMaps(h);</font></p> <p><font size="2">对于在类似于上面所说，使用了<font face="Times New Roman">? extend XXX</font>的方法，值得注意的一点是不能够在方法体内用<font face="Times New Roman">XXX</font>的子类对象作为代替。如下面一段代码是</font><strong>错误</strong><font size="2">的：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">public void addRectangle(List&lt;? extends Shape&gt; shapes) </font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#123; </font></p> <p style="text-indent:-45pt;"><font><font size="2"><font face="Courier New"><font color="#0000ff">        shapes.add(0, new Rectangle()); //</font> </font>错误用法<font face="Courier New">!</font></font></font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">这里我们假设<font face="Times New Roman">Rectangle</font>是<font face="Times New Roman">Shape</font>的一个子类。</font></p> <p><font size="2">不允许这样写的原因比较简单，因为调用该方法时候参数类型可能是<font face="Times New Roman">Shape</font>的另外一个子类。假如说<font face="Times New Roman">Shape</font>除了<font face="Times New Roman">Rectangle</font>这个子类以外还有另外一个子类<font face="Times New Roman">Circle</font>，那么我们可以把一个<font face="Times New Roman">List&lt;Circle&gt;</font>类型的对象作为参数传给这个方法（注意这样是合法的），而在方法体内却把一个<font face="Times New Roman">Rectangle</font>对象放到了<font face="Times New Roman">shapes</font>里面，这显然是不合理的。</font></p> <p><font size="2">除了<font face="Times New Roman">extends</font>，在泛型参数类型中还可以使用<font face="Times New Roman">super</font>关键字，参照下面一段程序：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">private void addString(Collection &lt;? super String&gt; c)</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#123;</font></p> <p style="text-indent:-45pt;"><font size="2"><font color="#0000ff"><font><font face="Courier New">         c.add(&quot;a String&quot;);</font></font></font></font></p> <p style="text-indent:-45pt;"><font size="2"><font color="#0000ff"><font><font face="Courier New">&#125; <p></p></font></font></font></font> <p></p> <font size="3">泛型函数</font> <p><font size="2">我们在前面提到了统配类型，现在让我们来设想一个函数，它实现这样的功能，将一个数组中的元素添加到一个<font face="Times New Roman">Collection</font>中，为了保证程序的通用性，我们可能会写出另外一段错误的代码：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">private void fromArrayToCollection(Object[] a, Collection&lt;?&gt; c) </font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#123; </font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font face="Courier New"><font><font size="2">        for (Object o : a) </font></font></font></font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font face="Courier New"><font><font size="2">        &#123; </font></font></font></font></p> <p style="text-indent:-45pt;"><font><font size="2"><font color="#0000ff"><font face="Courier New">         c.add(o); // </font></font>错误的代码</font></font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font><font face="Courier New"><font size="2">        &#125;</font></font></font></font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">那么这个函数应该怎么写呢？我们可以通过对函数添加泛型参数的方法实现，如下面所示：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">private &lt;T&gt; void  exfromArrayToCollection(T[] a,  Collection&lt;T&gt; c) </font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#123; </font></p> <p style="text-indent:-45pt;"><font face="Courier New"><font color="#0000ff"><font><font size="2">         for (T o : a) </font></font></font></font></p> <p style="text-indent:-45pt;"><font face="Courier New"><font color="#0000ff"><font><font size="2">         &#123; </font></font></font></font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font><font size="2"><font face="Courier New">            c.add(o); //</font>这样是正确的</font></font></font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font><font face="Courier New"><font size="2">         &#125;</font></font></font></font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p> <p><font face="Times New Roman" size="2"></font> </p> <p></p> <p><font size="2">那么，在什么时候我们应该使用统配类型，什么时候我们应该使用泛型函数呢？答案是取决于函数参数之间，函数参数和返回值之间的类型依赖性。</font></p> <p><font size="2">如果一个函数的参数类型与函数返回的参数没有必然关联，同时对于该函数其他的参数的类型也没有依赖关系，那么我们就应该使用统配符，否则就应该使用泛型函数。</font></p> <p><font size="2">为了更清楚地说明这一点，我们可以看一下<font face="Times New Roman">java.util</font>包中<font face="Times New Roman">Collections</font>类型几个方法的定义：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">class Collections &#123; </font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font><font face="Courier New"><font size="2">        static void swap(List&lt;?&gt; list, int i, int j) &#123;...&#125;</font></font></font></font></p> <p style="text-indent:-45pt;"><font color="#0000ff"><font><font face="Courier New"><font size="2">        static &lt;T&gt; void  copy                                 (List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)    &#123;...&#125;</font></font></font></font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">&#125;</font></p> <p><font size="2">其中<font face="Times New Roman">swap</font>函数实际上也可以这样定义：</font></p> <p style="text-indent:-45pt;"><font face="Courier New" color="#0000ff" size="2">static &lt;T&gt;void swap(List&lt;T&gt; list, int i, int j) &#123;...&#125;</font></p> <p><font size="2">但是注意到这里泛型类型参数<font face="Times New Roman">T</font>只在参数中用到了一次，也就是说它和函数其他部分没有依赖性，这可以看作是我们应该使用<font face="Times New Roman">?</font>的一个标志。</font></p> <p><font size="2"><font face="Times New Roman">copy</font>方法中，拷贝源<font face="Times New Roman">src</font>中的元素必须是<font face="Times New Roman">dest</font>所能够接受的，<font face="Times New Roman">src</font>中的元素必须是<font face="Times New Roman">T</font>的一个子类，但是具体它是哪种子类我们又不必关心，所以方法中使用了泛型作为一个类型参数，同时也用了统配类型作为第二类型参数</font></p></div>
